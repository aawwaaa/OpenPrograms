NAME
  gmux-app - gmux applications overview and development guide

SYNOPSIS
  Applications in gmux provide user-facing functionality through graphical interfaces.

DESCRIPTION
  Gmux applications are modular programs that run in isolated graphical environments.
  Each application has its own window, process, and virtual components. Applications
  are loaded from the /usr/share/gmux/apps/ directory and can be launched from
  the desktop environment.

APPLICATIONS
  shell
    Command line terminal providing access to system commands and programs.
    Runs the OpenOS shell in a graphical window with full terminal functionality.
    See gmux-app-shell(1) for detailed information.

  monitor
    System resource monitor displaying real-time information about processes,
    memory usage, CPU usage, and component status. Provides process management
    capabilities including process termination and information display.
    See gmux-app-monitor(1) for detailed information.

  run
    Program launcher that allows users to start custom applications by specifying
    a file path. Creates a new graphical window for the launched program.
    See gmux-app-run(1) for detailed information.

  exit
    System exit utility that provides a confirmation dialog before shutting down
    the gmux desktop environment. Ensures clean system shutdown.
    See gmux-app-exit(1) for detailed information.

  lua_repl
    Interactive Lua interpreter providing a graphical REPL environment for
    testing and development. Allows direct execution of Lua code with immediate
    feedback and error reporting.
    See gmux-app-lua_repl(1) for detailed information.

  simulator
    Advanced component simulator for testing and development. Provides a virtual
    environment with configurable components including filesystems, EEPROMs,
    GPUs, screens, and keyboards. Supports custom machine configurations.
    See gmux-app-simulator(1) for detailed information.

APPLICATION STRUCTURE
  Each application follows a standard structure defined in its main file:

  Basic Structure:
    return {
        name = "Application Name",
        draw_icon = function(gpu, colors, x, y)
            -- Icon drawing code
        end,
        graphics_process = {
            width = 80, height = 25,
            main_path = "/path/to/main.lua",
            name = "Process Name"
        }
    }

  Required Fields:
    - name: Display name for the application
    - draw_icon: Function to render the application icon
    - graphics_process: Process configuration object

  Graphics Process Options:
    - width/height: Window dimensions in characters
    - main_path: Path to the main application file
    - main: Direct function reference (alternative to main_path)
    - name: Process name for identification

ICON DEVELOPMENT
  Application icons are drawn using the GPU component with a standardized
  color scheme. The draw_icon function receives:

  Parameters:
    - gpu: GPU component for drawing operations
    - colors: Color scheme object with background, primary, secondary, text
    - x, y: Icon position coordinates

  Color Scheme:
    - colors.background: Background color
    - colors.primary: Primary accent color
    - colors.secondary: Secondary accent color
    - colors.text: Text color

  Icon Guidelines:
    - Icons should be 9x5 characters in size
    - Use the provided color scheme for consistency
    - Create distinctive visual representations
    - Ensure readability at small sizes

PROCESS MANAGEMENT
  Applications run in isolated processes with dedicated resources:

  Virtual Components:
    - Virtual GPU: Isolated graphics context
    - Virtual Keyboard: Independent input handling
    - Virtual Screen: Dedicated display management

  Process Isolation:
    - Independent event handling
    - Isolated component access
    - Separate memory space
    - Independent error handling

  Process Lifecycle:
    1. Application file loaded and parsed
    2. Graphics process created with virtual components
    3. Window created and displayed
    4. Application runs until window closed
    5. Process terminated and resources cleaned up

DEVELOPMENT WORKFLOW
  1. Create application file in /usr/share/gmux/apps/
  2. Implement the standard application structure
  3. Create the main application logic file
  4. Test the application in the gmux environment
  5. Add to the .order file for proper loading sequence

  Example Development:
    -- /usr/share/gmux/apps/myapp.lua
    return {
        name = "My Application",
        draw_icon = function(gpu, colors, x, y)
            gpu.setBackground(colors.background)
            gpu.setForeground(colors.primary)
            gpu.set(x, y, "MyApp")
        end,
        graphics_process = {
            width = 60, height = 20,
            main_path = "/home/user/myapp_main.lua",
            name = "MyApp"
        }
    }

ERROR HANDLING
  Applications should implement proper error handling:

  Process Errors:
    - Errors are displayed in popup windows
    - Process termination is handled gracefully
    - Resource cleanup occurs automatically

  Development Errors:
    - Syntax errors prevent application loading
    - Runtime errors are caught and displayed
    - Invalid configurations are reported

SEE ALSO
  gmux(1), gmux-plugin(1),
  gmux-app-shell(1), gmux-app-monitor(1), gmux-app-run(1),
  gmux-app-exit(1), gmux-app-lua_repl(1), gmux-app-simulator(1) 