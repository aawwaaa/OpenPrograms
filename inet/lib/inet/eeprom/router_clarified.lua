-- OpenComputers Network Router Implementation
-- Clarified version with full variable names and proper formatting
-- Generated by Cursor

-- Component and computer libraries
component = component
computer = computer

-- Function to get component proxy
getComponent = function(componentType)
    return component.proxy(component.list(componentType)())
end

-- Initialize modem component
modem = getComponent("modem")
modemAddress = modem.address

-- Initialize EEPROM component
eeprom = getComponent("eeprom")

-- Signal pushing function
pushSignal = computer.pushSignal

-- Configuration table
config = {
    [".exa"] = "example_name",
    connect = "",
    connect_verify = "",
    hidden = false,
    password = "",
    name = "Router-" .. modemAddress:sub(1, 8),
    wireless_strength = 400
}

-- Extract configuration values
connect = config.connect
name = config.name
password = config.password

-- Connection state variables
partner = nil
address = nil
state = -1
timeout = nil
broadcastAddress = nil

-- Beep function
beep = computer.beep

-- Connection tables
devices = {}
deferredDevices = {}
accepted = {}

-- Open modem on port 10251
modem.open(10251)

-- Send function
send = function(target, ...)
    modem.send(target, 10251, ...)
end

-- Broadcast function
broadcast = function(...)
    modem.broadcast(10251, ...)
end

-- Get short name function (first 3 characters)
nameShort = function(str)
    return str:sub(1, 3)
end

-- Uptime function
uptime = computer.uptime

-- Time tracking variables
lastTime = uptime()
pingTime = uptime()
loopTime = uptime()

-- Info formatting function
info = function(key, value, ...)
    return key and "| " .. key .. "=" .. tostring(value) .. info(...) or ""
end

-- Event handlers
events = {
    -- Handle modem messages
    modem_message = function(sender, port, distance, message, ...)
        if port == 10251 and distance < 5 then
            if message == "." then
                -- Status request
                send(sender, ":", "", info("Pa", nameShort(partner or "nil"), "Es", state, "Ad", address, "Ba", broadcastAddress, "Fm", computer.freeMemory()))
                for key, value in pairs(config) do
                    send(sender, ":", key, value)
                end
                return
            elseif message == "=" then
                -- Configuration update
                beep(1000)
                config = ...
                eeprom.set(eeprom.get():gsub("\nCf=[^\n]*", "\nCf=" .. config))
                computer.shutdown(true)
            end
        elseif (".=:,"):match("%" .. message) then
            return
        end
        pushSignal("inet", nil, sender, message, ...)
    end,
    
    -- Handle inet messages
    inet = function(sender, message, ...)
        if message:sub(1, 1) == "m" then
            return messages.m(sender, message, ...)
        elseif messages[message] then
            return messages[message](sender, ...)
        end
    end
}

-- Message handlers
messages = {
    -- Client message handlers
    P = function(sender, ...)
        -- Partner connection request
        if sender:sub(1, #connect) == connect and state < 0 then
            partner = sender
            accepted[sender] = true
            send(partner, "v", config.connect_verify)
        end
    end,
    
    V = function(sender, result, errorMessage)
        -- Verification response
        if not result then
            address = "Verify failed " .. errorMessage
            state = -1
        end
        state = 0
        send(sender, "a", modemAddress)
    end,
    
    A = function(sender, device, addr, timeoutValue)
        -- Address assignment
        address = addr
        state = 1
        local pa = addr:match("^(.+)%.") or ""
        broadcastAddress = pa .. (pa ~= "" and "." or "") .. "~"
        pingTime = uptime() + 5
        timeout = timeoutValue
    end,
    
    f = function(sender, device)
        -- Find device request
        if nameShort(modemAddress) == device then
            send(sender, "F", device)
        end
    end,
    
    C = function()
        -- Connection keepalive
        pingTime = uptime() + 5
    end,
    
    -- Access point message handlers
    p = function(sender)
        -- Access point advertisement
        if state == 1 and sender ~= partner and not config.hidden then
            send(sender, "P", address or "l", name, password ~= "" and "password" or nil)
        end
    end,
    
    c = function(sender, target)
        -- Connection confirmation
        if state == 1 then
            send(sender, "C")
            devices[target or nameShort(sender)] = sender
        end
    end,
    
    v = function(sender, pass)
        -- Password verification
        if pass == password or password == "" then
            accepted[sender] = true
            send(sender, "V", true)
        else
            send(sender, "V", false, pass == "" and "Password is required" or "Password is incorrect")
        end
    end,
    
    -- Router message handlers
    a = function(sender, device)
        -- Address resolution
        if not accepted[sender] then
            send(sender, "!")
        else
            local targetHost = config["." .. nameShort(device)] or nameShort(device)
            send(sender, "A", device, address .. "." .. targetHost, targetHost)
            devices[targetHost] = sender
        end
    end,
    
    F = function(sender, device)
        -- Found device response
        devices[device] = sender
        if deferredDevices[device] then
            deferredDevices[device](sender)
            deferredDevices[device] = nil
        end
    end,
    
    m = function(sender, message, ...)
        -- Message routing
        if not accepted[sender] then
            send(sender, "!")
        else
            local source, destination, id = message:match("^m!(.+)@([^#]+)#?(.*)$")
            if destination:sub(1, #address) == address then
                local nextHop = destination:match("^" .. address:gsub("%.", "%%.") .. "%.([^%.]*)")
                if devices[nextHop] == sender then
                    return
                end
                if nextHop == "~" then
                    return broadcast(message, ...)
                end
                if devices[nextHop] then
                    return send(devices[nextHop], message, ...)
                else
                    broadcast("f", nextHop)
                    local packed = table.pack(message, ...)
                    deferredDevices[nextHop] = function(s)
                        send(s, table.unpack(packed))
                    end
                end
            elseif destination:sub(1, #broadcastAddress) == broadcastAddress and sender == partner then
                return broadcast("m!" .. source .. "@" .. address .. ".~" .. (destination:match("^" .. broadcastAddress:gsub("%.", "%%.") .. (broadcastAddress and "%." or "") .. "~(.*)") or ""), ...)
            else
                send(partner, message, ...)
            end
        end
    end
}

-- Start advertising as access point
broadcast("p")

-- Set wireless strength if modem is wireless
if modem.isWireless() then
    modem.setStrength(config.wireless_strength)
end

-- Main router loop
while true do
    local signal = table.pack(computer.pullSignal(0.5))
    if signal[1] and events[signal[1]] then
        local success, error = xpcall(events[signal[1]], debug.traceback, table.unpack(signal, 3))
        if not success then
            broadcast(",", table.unpack(signal, 3), error)
        end
    end
    
    if loopTime + 0.45 < uptime() then
        -- Periodic tasks
        if uptime() > lastTime + 5 and state == -1 then
            broadcast("p")
            lastTime = uptime()
        end
        
        if state == 1 and uptime() > pingTime then
            send(partner, "c", timeout)
            if uptime() > pingTime + 10 then
                state = -1
                deferredDevices = {}
                partner = nil
                devices = {}
            end
        end
        
        loopTime = uptime()
    end
end 