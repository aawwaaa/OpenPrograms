-- OpenComputers Network Switch Implementation
-- Clarified version with full variable names and proper formatting
-- Generated by Cursor

-- Component and computer libraries
component = component
computer = computer

-- Function to get component proxy
getComponent = function(componentType)
    return component.proxy(component.list(componentType)())
end

-- Initialize modem component
modem = getComponent("modem")
modemAddress = modem.address

-- Initialize EEPROM component
eeprom = getComponent("eeprom")

-- Signal pushing function
pushSignal = computer.pushSignal

-- Configuration table
config = {
    connect = "",
    name = "Switch-c64eeb54",
    password = "",
    [".fff"] = "hello",
    hidden = false,
    wireless_strength = 400,
    connect_verify = ""
}

-- Extract configuration values
connect = config.connect
name = config.name
password = config.password

-- Connection state variables
partner = nil
address = nil
state = -1

-- Beep function
beep = computer.beep

-- Connection tables
devices = {}
accepted = {}
switchConnections = {}

-- Open modem on port 10251
modem.open(10251)

-- Send function
send = function(target, ...)
    modem.send(target, 10251, ...)
end

-- Broadcast function
broadcast = function(...)
    modem.broadcast(10251, ...)
end

-- Get short name function (first 3 characters)
nameShort = function(str)
    return str:sub(1, 3)
end

-- Uptime function
uptime = computer.uptime

-- Time tracking variables
lastTime = uptime()
pingTime = uptime()
loopTime = uptime()

-- Info formatting function
info = function(key, value, ...)
    return key and "| " .. key .. "=" .. tostring(value) .. info(...) or ""
end

-- Event handlers
events = {
    -- Handle modem messages
    modem_message = function(sender, port, distance, message, ...)
        if port == 10251 and distance < 5 then
            if message == "." then
                -- Status request
                send(sender, ":", "", info("Pa", nameShort(partner or "nil"), "Es", state, "Fm", computer.freeMemory()))
                for key, value in pairs(config) do
                    send(sender, ":", key, value)
                end
                return
            elseif message == "=" then
                -- Configuration update
                beep(1000)
                config = ...
                eeprom.set(eeprom.get():gsub("\nCf=[^\n]*", "\nCf=" .. config))
                computer.shutdown(true)
            end
        elseif (".=:,"):match("%" .. message) then
            return
        end
        pushSignal("inet", nil, sender, message, ...)
    end,
    
    -- Handle inet messages
    inet = function(sender, message, ...)
        if message:sub(1, 1) == "m" then
            return messages.m(sender, message, ...)
        elseif messages[message] then
            return messages[message](sender, ...)
        end
    end
}

-- Message handlers
messages = {
    -- Client functions
    P = function(sender, address, ...)
        if sender:sub(1, #connect) == connect and state < 0 then
            partner = sender
            accepted[sender] = true
            send(partner, "v", config.connect_verify)
            address = address
        end
    end,
    
    V = function(sender, result, message)
        if not result then
            address = "Verify failed " .. message
            state = -1
        end
        state = 1
    end,
    
    C = function()
        pingTime = uptime() + 5
    end,
    
    -- Access point functions
    p = function(sender)
        if state == 1 and sender ~= partner and not config.hidden then
            send(sender, "P", address or "l", name, password ~= "" and "password" or nil)
        end
    end,
    
    c = function(sender, target)
        if state == 1 then
            send(sender, "C")
            devices[target or nameShort(sender)] = sender
        end
    end,
    
    v = function(sender, pass)
        if pass == password or password == "" then
            accepted[sender] = true
            send(sender, "V", true)
        else
            send(sender, "V", false, pass == "" and "Password is required" or "Password is incorrect")
        end
    end,
    
    -- Switch functions
    a = function(sender, device)
        if not accepted[sender] then
            send(sender, "!")
        else
            switchConnections[device] = sender
            send(partner, "a", device)
        end
    end,
    
    A = function(sender, device, address, target)
        send(switchConnections[device], "A", device, address, target)
        devices[target] = switchConnections[device]
        switchConnections[device] = nil
    end,
    
    f = function(sender, device)
        if nameShort(modemAddress) == device and sender == partner then
            send(sender, "F", device)
        else
            broadcast("f", device)
            switchConnections[device] = sender
        end
    end,
    
    F = function(sender, device)
        devices[device] = sender
        send(switchConnections[device], "F", device)
        switchConnections[device] = nil
    end,
    
    m = function(sender, message, ...)
        if not accepted[sender] then
            send(sender, "!")
        else
            local source, destination, id = message:match("^m!(.+)@([^#]+)#?(.*)$")
            if destination:sub(1, #address) == address then
                local network = destination:match("^" .. address:gsub("%.", "%%.") .. (address ~= "" and "%." or "") .. "([^%.]*)")
                if devices[network] == sender then
                    return
                end
                if network == "~" then
                    if sender ~= partner then
                        return send(partner, message, ...)
                    end
                    for _, device in pairs(devices) do
                        if device ~= partner then
                            send(device, message, ...)
                        end
                    end
                    return
                end
                if devices[network] then
                    return send(devices[network], message, ...)
                else
                    return send(partner, message, ...)
                end
            else
                send(partner, message, ...)
            end
        end
    end
}

-- Initial broadcast
broadcast("p")

-- Set wireless strength if modem is wireless
if modem.isWireless() then
    modem.setStrength(config.wireless_strength)
end

-- Main event loop
while true do
    local signal = table.pack(computer.pullSignal(0.5))
    if signal[1] and events[signal[1]] then
        local success, error = xpcall(events[signal[1]], debug.traceback, table.unpack(signal, 3))
        if not success then
            broadcast(",", table.unpack(signal, 3), error)
        end
    end
    
    if loopTime + 0.45 < uptime() then
        if uptime() > lastTime + 5 and state == -1 then
            broadcast("p")
            lastTime = uptime()
        end
        
        if state == 1 and uptime() > pingTime then
            send(partner, "c")
            if uptime() > pingTime + 10 then
                state = -1
                partner = nil
                devices = {}
            end
        end
        
        loopTime = uptime()
    end
end 